Perfecto — aquí tienes **el prompt definitivo, ultra-detallado y listo para pasar a una IA de programación o a un desarrollador**. Cubre **todo**: arquitectura, APIs, firmas de funciones, pseudocódigo reproducible, formato de salida JSON, diseño visual para NinjaTrader y para paneles externos, publishers (WebSocket / Telegram / fichero), configuración, tests y criterios de aceptación. Está pensado para que el desarrollador **no tenga dudas** y pueda comenzar a implementar de inmediato.

---

# PROMPT: IMPLEMENTACIÓN DEL DECISION ENGINE + VISUAL LAYER (PRO, LISTO PARA DESARROLLO)

**Objetivo**
Desarrollar un módulo llamado **DecisionEngine** y una capa visual **VisualLayer** (NinjaTrader UI + preparada para panel web/app/telegram) que consuman los datos del `CoreEngine` (ya existente: detección y scoring de estructuras) y produzcan **decisiones operativas** y **visualizaciones humanas** claras, ricas e interpretables.

**Alcance**

* DecisionEngine: lógica que agrega, pondera y sintetiza la información del Core para generar zonas, bias, señales y SL/TP sugeridos. Exporta snapshot JSON y eventos para consumidores.
* VisualLayer: visualización en NinjaTrader (overlays y panel lateral), y adaptadores para publicar a WebSocket / archivo JSON / Telegram. Preparado para migrar a web/app sin reescritura del core.

---

## Entregables esperados (archivos y artefactos)

* `DecisionEngine.cs` (lógica principal)
* `DecisionModels.cs` (clases DTO: DecisionSnapshot, HeatZone, TradeDecision, etc.)
* `ContextManager.cs` (calcula bias, market clarity)
* `StructureFusion.cs` (fusiona estructuras en POIs/zones)
* `ProximityAnalyzer.cs`
* `DecisionScorer.cs`
* `SignalSynthesizer.cs`
* `OutputAdapter.cs` + publishers:

  * `JsonFilePublisher.cs`
  * `WebSocketPublisher.cs`
  * `TelegramPublisher.cs` (usa Bot API; token configurable)
* `VisualLayerNinja.cs` (indicador NinjaScript que dibuja overlays y panel lateral; consume DecisionEngine via API o JSON)
* `DashboardSpec.md` (especificación para panel web: endpoints WebSocket, JSON schema)
* `TestSuite.cs` (RunSelfDiagnostics + unit tests)
* `README.md` (español, instalación, parámetros, ejemplos)
* `decision_snapshot_example.json`
* Documentación inline en español (comentarios)

---

## 1) Principios de diseño

1. **Separación de responsabilidades**: DecisionEngine solo procesa datos y expone resultados; VisualLayer solo dibuja/expone. CoreEngine sigue siendo la fuente de verdad para estructuras técnicas.
2. **Configuración central**: `DecisionConfig` serializable (todos parámetros ajustables).
3. **Interoperabilidad**: Salidas neutrales (JSON) y eventos (C#) para conectar con UIs externas o bots.
4. **Safe-by-default**: Si hay conflicto o falta de datos, el motor prioriza `WAIT/NO_ACTION` sobre señales arriesgadas.
5. **Explicabilidad**: cada decisión debe exponer las estructuras que la originaron (lista de IDs) y el razonamiento numérico (sub-scores).

---

## 2) Interfaces y modelos de datos (firmas exactas)

### 2.1 `DecisionEngine` — constructor y principales métodos

```csharp
public class DecisionEngine
{
    public DecisionEngine(CoreEngine coreEngine, DecisionConfig config);
    public void Initialize(); // registra eventos del core, inicializa timers
    public void OnCoreUpdate(); // invocado cuando CoreEngine actualiza (o evento)
    public DecisionSnapshot GetLatestSnapshot(); // copia inmutable
    public event Action<DecisionSnapshot> OnSnapshotUpdated; // suscribibles
    public void RunSelfDiagnostics(); // tests locales
    public void Dispose();
}
```

### 2.2 Modelos principales (`DecisionModels.cs`)

```csharp
public class DecisionSnapshot {
    public DateTime TimestampUtc { get; set; }
    public string Instrument { get; set; }
    public double CurrentPrice { get; set; }
    public MarketBiasInfo Bias { get; set; }
    public List<HeatZone> HeatZones { get; set; } = new();
    public List<TradeDecision> TradeDecisions { get; set; } = new();
    public SummaryInfo Summary { get; set; }
    public Dictionary<string, object> DebugInfo { get; set; } = new();
}

public class MarketBiasInfo {
    public string Global { get; set; } // "Bullish","Bearish","Neutral"
    public string Local { get; set; }
    public double Strength { get; set; } // 0..1
    public double Confidence { get; set; } // 0..1
    public string Notes { get; set; } // breve explicación
}

public class HeatZone {
    public string Id { get; set; } // por ejemplo: "FVG_60_20251022_..."
    public string Type { get; set; } // "FVG","OB","POI",...
    public string Direction { get; set; } // "Bullish"/"Bearish"/"Neutral"
    public double Low { get; set; }
    public double High { get; set; }
    public double Score { get; set; } // 0..1
    public int TouchCountBody { get; set; }
    public int TouchCountWick { get; set; }
    public string Status { get; set; } // "Active","Nearby","Filled","Mitigated"
    public List<string> SourceStructureIds { get; set; } = new();
    public Dictionary<string,object> Metadata { get; set; } = new();
}

public class TradeDecision {
    public string Id { get; set; }
    public string Type { get; set; } // "BuySetup","SellSetup","TakePartial","Close","Wait"
    public double Confidence { get; set; } // 0..1
    public double Entry { get; set; } // precio sugerido (limit/market)
    public double StopLoss { get; set; }
    public double TakeProfit { get; set; }
    public string Action { get; set; } // "WAIT","BUY_LIMIT","SELL_LIMIT","BUY_MARKET","SELL_MARKET"
    public List<string> SourceStructureIds { get; set; } = new();
    public string Rationale { get; set; } // texto explicativo breve
}
```

### 2.3 `DecisionConfig` (parámetros configurables)

Debe ser serializable y editable desde la UI del wrapper:

```text
DecisionConfig {
  TimeframesWeighting: Dictionary<int,double> // e.g. 1440:1.0,240:0.7,60:0.45,15:0.25
  BiasThresholdMultiplier: 1.2
  MarketClarityThreshold: 0.25
  MinConfidenceForTrade: 0.65
  ProximityFactorATR: 2.5 // para convertir ATR a distancia de interés
  MaxZonesToDisplay: 8
  HeatmapColorPalette: enum // "Default","HighContrast",...
  SLTP_RiskRewardMin: 1.5
  SLTP_RiskPerTradePct: 0.5 // para cálculo monetario si requerido
  PublisherConfigs: {JsonFile:{enabled,path}, WebSocket:{enabled,port,route}, Telegram:{enabled,botToken,chatId}}
  VisualConfig: {...} // parámetros de panel
}
```

---

## 3) Flujo de datos y procesos internos (arquitectura de ejecución)

1. **Trigger**: CoreEngine detecta/actualiza estructuras ? dispara evento `OnCoreUpdate` (o DecisionEngine lo consulta periódicamente si preferible).
2. **ContextManager** obtiene:

   * Listado de estructuras activas (filtrado por min score).
   * Market metrics: ATRs, volatility, recent BOS/CHoCH.
3. **StructureFusion** agrupa estructuras solapadas en POIs, calcula confluence, produce HeatZones.
4. **ProximityAnalyzer** calcula distancia entre precio actual y cada HeatZone ? produce `proximityScore` basado en `ProximityFactorATR * ATR(tf)`.
5. **DecisionScorer** para cada HeatZone calcula `zoneScore` (combinación normalizada: score_core * proximityFactor * confluenceFactor * trendAlignment).
6. **SignalSynthesizer** evalúa reglas y thresholds para generar `TradeDecision`s (BuySetup, SellSetup, Wait, etc).
7. **DecisionSnapshot** se genera, el `OnSnapshotUpdated` se emite y `OutputAdapter` publica (JSON file, WebSocket, Telegram). VisualLayer consume snapshot para dibujar.

---

## 4) Algoritmos y reglas (pseudocódigo implementable)

### 4.1 Cálculo de fuerza agregada (BullishStrength / BearishStrength)

```csharp
double AggregateStrength(string direction, List<HeatZone> zones) {
    // zones filtered by direction
    double sumWeighted = 0;
    double weightSum = 0;
    foreach(var z in zones) {
        double tfWeight = DecisionConfig.TimeframesWeighting[z.Metadata["TF"]]; // asegurar key
        double proximityFactor = z.Metadata.ContainsKey("ProximityScore") ? (double)z.Metadata["ProximityScore"] : 1.0;
        double typeBonus = TypeWeight(z.Type); // OB>POI>FVG>SWING etc.
        double w = tfWeight * proximityFactor * typeBonus;
        sumWeighted += z.Score * w;
        weightSum += w;
    }
    return weightSum > 0 ? sumWeighted / weightSum : 0.0; // normalized 0..1
}
```

### 4.2 Determinar bias

```csharp
bull = AggregateStrength("Bullish", zones);
bear = AggregateStrength("Bearish", zones);
if (bull > bear * DecisionConfig.BiasThresholdMultiplier && (bull - bear) > DecisionConfig.MarketClarityThreshold)
    GlobalBias = "Bullish", Strength = (bull - bear);
else if (bear > bull * DecisionConfig.BiasThresholdMultiplier && (bear - bull) > DecisionConfig.MarketClarityThreshold)
    GlobalBias = "Bearish", Strength = (bear - bull);
else
    GlobalBias = "Neutral", Strength = 1.0 - Math.Abs(bull - bear);
```

### 4.3 ProximityScore (por zona)

```csharp
double ProximityScore(HeatZone z, double currentPrice, double atr) {
    double center = (z.Low + z.High)/2.0;
    double distance = Math.Abs(currentPrice - center);
    double proxMax = DecisionConfig.ProximityFactorATR * atr;
    double score = 1.0 - Math.Min(distance / proxMax, 1.0); // 1.0 si en centro, 0 si fuera de proxMax
    return Math.Max(0.0, score);
}
```

### 4.4 ZoneScore final

```csharp
zoneScore = z.Score * 0.6 + (proximityScore * 0.3) + (confluenceNormalized * 0.1);
// luego normalizar y aplicar trend alignment multiplier si z.Direction == GlobalBias
if (z.Direction == GlobalBias) zoneScore *= TrendAlignmentMultiplier; // e.g., 1.15
zoneScore = Clamp(zoneScore, 0.0, 1.0);
```

### 4.5 Generador de TradeDecision (reglas base)

Regla ejemplo para `BuySetup` (configurable):

* condiciones:

  * zone.Direction == "Bullish"
  * zoneScore = DecisionConfig.MinConfidenceForTrade
  * price dentro `proximityThreshold` (por ejemplo proximityScore = 0.6)
  * no conflicto con higher TF BOS contra (si hay BOS fuerte en contra, require confirmation)

* acción:

  * Entry: `limit` en center o en `zone.Low + small_offset`
  * SL: `zone.Low - SL_buffer` (por ejemplo SL_buffer = ATR*0.5)
  * TP: calcular según `RiskRewardMin` y nearest resistance zone o next POI
  * Confidence: zoneScore

Pseudocódigo:

```csharp
if (zone.Direction == "Bullish" && zoneScore >= MinConfidenceForTrade && proximityScore >= 0.6) {
    double entry = zone.Center; // o zone.Low + epsilon
    double sl = zone.Low - atr * 0.5;
    double tp = entry + Math.Max((entry - sl) * DecisionConfig.SLTP_RiskRewardMin, NextResistanceDistance);
    create TradeDecision { Type="BuySetup", Entry=entry, StopLoss=sl, TakeProfit=tp, Confidence=zoneScore, SourceStructureIds = z.SourceStructureIds, Rationale = "..." };
}
```

**Notas**: Reglas deben ser estrictas en vivo; añadir opcional “soft mode” para paper trading.

---

## 5) VisualLayer — diseño para NinjaTrader (detalles técnicos)

**Objetivo**: mostrar las zonas y decisiones de forma **compacta, visual y prioritaria**, sin saturar el gráfico.

### 5.1 Elementos gráficos

1. **Heatzone rectangles**: dibujar como `Draw.Rectangle` con color basado en `HeatZone.Score`.

   * Color base: Bullish ? verde/azul; Bearish ? rojo/orange.
   * Alpha = 60% × Score (o proporcional).
   * Glow: dibujar un `Draw.Ellipse` difuso (si NT lo permite) o una segunda rect con mayor blur-simulado.

2. **Zone border**: grosor según `Score` (ej. score>0.8 => thick).

3. **Labels**: `Draw.Text` con resumen compacto:

   * `ID | Type | Score% | TouchBody/X | DistTicks`
   * Mostrar solo top `MaxZonesToDisplay` (configurable).

4. **Panel lateral (compacto)**: (puede ser un `Draw.TextFixed` o un panel custom)

   * Bias global/local, Strength bar (horizontal gauge).
   * Listado ordenado de top 5 HeatZones con actionable buttons (si NT permite events).
   * Current recommended action (TradeDecision) con Entry/SL/TP.

5. **Mini-heatmap overlay**: barra vertical a la izquierda con bands representing score intensity per price level (if performance allows).

### 5.2 Interactivity & UX

* `EnableDebug` mode displays raw IDs and structure lists in panel.
* Hover or click (if NT supports) should expose `Rationale` (short text).
* Auto-refresh on `OnSnapshotUpdated` event; redraw only changed elements to avoid flicker.

### 5.3 Visual config (DecisionConfig.VisualConfig)

* `HeatMaxOpacity`, `HeatMinOpacity`, `ColorPalette`, `LabelFontSize`, `PanelWidthPx`, `MaxZonesToDisplay`.

---

## 6) OutputAdapter + Publishers (implementaciones)

### 6.1 JSON File Publisher

* `JsonFilePublisher` guarda `DecisionSnapshot` en `decision_snapshot.json` (overwrite) y mantiene a salvo `N` históricos (rotación configurable).
* Guardado asíncrono (Task.Run) con debounce (no más de 1 por `StateSaveIntervalSecs`).

### 6.2 WebSocket Publisher

* `WebSocketPublisher` expone un endpoint `ws://localhost:{port}/{route}`.
* Envía `DecisionSnapshot` en JSON cada vez que se actualiza (o en intervalos configurables).
* Implementar keepalive ping/pong y control de suscriptores.

### 6.3 Telegram Publisher

* `TelegramPublisher` toma `BotToken` y `ChatId`.
* Envía mensajes resumidos (texto) cuando `TradeDecision` con `Confidence >= TelegramMinConfidence` se genera.
* Mensaje corto + enlace a `decision_snapshot.json` local (si se desea).
* Rate limit configurable.

---

## 7) API y contratos (JSON schema resumido)

**DecisionSnapshot (esquema breve)** — ya definido arriba. Entregar JSON Schema (Draft-07) en README.

---

## 8) Tests y RunSelfDiagnostics (detalles)

`RunSelfDiagnostics()` debe crear escenarios sintéticos y validar:

* **Caso 1**: Confluencia alcista clara ? produce BuySetup con Confidence = 0.7.
* **Caso 2**: CHoCH contrario en TF alto ? no generar BuySetup aunque zoneScore alta (requiere confirmation).
* **Caso 3**: FVG con solo wicks ? HeatZone Active pero low Confidence.
* **Caso 4**: OB con volumen spike ? OB zone higher priority (type weight tested).
* **Caso 5**: Market volatile -> SL/TP widen and TP strategies adjusted.

Para cada caso, generar `diagnostics.json` y assertions programadas (unit tests).

---

## 9) Criterios de aceptación (QA)

1. El DecisionEngine produce `DecisionSnapshot` en menos de 200ms tras `OnCoreUpdate` con up to 200 estructuras.
2. VisualLayer muestra correctamente top `MaxZonesToDisplay` y actualiza sin flicker.
3. WebSocketPublisher soporta al menos 5 conexiones simultáneas y envía snapshots correctamente en JSON.
4. TelegramPublisher envía mensajes de forma rate-limited según config.
5. RunSelfDiagnostics produce outputs esperados y tests pasan.
6. Documentación completa en README.

---

## 10) Recomendaciones operativas y mejoras futuras

1. **Modo simulación**: permitir “simulate only” donde DecisionEngine emite decisiones pero no publica a Telegram ni WebSocket (modo para validar).
2. **Historial de decisiones**: guardar log de `TradeDecision` y resultados (P&L si se conecta con ejecuciones) para análisis post-hoc y ML.
3. **Explainability**: cada TradeDecision incluir puntajes parciales (howMuch each factor contributed) para auditoría.
4. **A/B Rulesets**: permitir múltiples sets de reglas (conservative/aggressive) seleccionables en config.
5. **Telemetría**: exponer `EngineStats` (avg processing time, number of zones, last save time) en JSON para monitorización.

---

## 11) Prioridad de implementación sugerida (roadmap)

**Sprint 1 (MVP visual y decisional básico)**

* Implementar DecisionEngine skeleton, DecisionModels, ContextManager básico (aggregate strengh), StructureFusion simple, ProximityAnalyzer, basic DecisionScorer.
* Implementar JSON publisher y VisualLayerNinja básico (rectangles + panel summary).
* Tests básicos y RunSelfDiagnostics mínimo.

**Sprint 2 (Reglas completas y publishers)**

* Implementar SignalSynthesizer, full SL/TP heuristics, WebSocketPublisher, TelegramPublisher.
* Mejorar visuals (heat halos, labels).
* Extend tests.

**Sprint 3 (Optimización y polish)**

* Perf tuning, UX polish, telemetry, historic logging, advanced rules.

---

## 12) Ejemplos de outputs concretos (para QA y validación)

**Ejemplo 1 — Snapshot (JSON)**

```json
{
  "timestamp":"2025-10-23T16:00:00Z",
  "instrument":"ES 12-25",
  "currentPrice":4700.25,
  "bias":{"global":"Bullish","local":"Bullish","strength":0.72,"confidence":0.78,"notes":"BOS H4 + confluence OB+FVG"},
  "heatZones":[
    {"Id":"FVG_60_20251023_01","Type":"FVG","Direction":"Bullish","Low":4685.5,"High":4692.0,"Score":0.83,"TouchCountBody":1,"Status":"Active"},
    {"Id":"OB_240_20251022_09","Type":"OB","Direction":"Bullish","Low":4670.0,"High":4680.0,"Score":0.77,"Status":"Nearby"}
  ],
  "tradeDecisions":[
    {"Id":"TD_001","Type":"BuySetup","Confidence":0.76,"Entry":4690.0,"StopLoss":4675.0,"TakeProfit":4720.0,"Action":"BUY_LIMIT","Rationale":"Confluencia FVG+OB, bias bullish H4, proximity high"}
  ],
  "summary":{"volatilityATR":10.2,"trendSlope":0.62,"marketCondition":"Trending"}
}
```

**Ejemplo 2 — Mensaje Telegram (texto corto)**

```
[ALERT] BuySetup ES 12-25
Conf: 76%
Entry 4690.0 SL 4675.0 TP 4720.0
Razon: FVG+OB confluence, Bias H4 Bullish.
```

---

## 13) Notas críticas y recomendaciones finales para el equipo de desarrollo

* **Documentar cada regla** (cómo se calculan thresholds) y exponer parámetros en `DecisionConfig` para que el trader pueda afinar sin tocar código.
* **Probar en paper/live demo** con logs completos antes de permitir cualquier ejecución automática.
* **Mantener la API de snapshot estable** (versioning) para que dashboards y bots no rompan con cambios.
* **Logging**: registrar por defecto `DEBUG` durante desarrollo; en producción usar `INFO` y alertas críticas en `WARN/ERROR`.

---

## 14) Checklist final para el desarrollador (copy/paste)

* [ ] Crear `DecisionEngine` y modelos.
* [ ] Implementar `ContextManager`, `StructureFusion`, `ProximityAnalyzer`, `DecisionScorer`, `SignalSynthesizer`.
* [ ] Implementar `OutputAdapter` y publishers (JSON, WebSocket, Telegram).
* [ ] Crear `VisualLayerNinja` con rectangles, labels, panel lateral.
* [ ] Implementar `RunSelfDiagnostics` y tests.
* [ ] Añadir documentación, ejemplos JSON y README.
* [ ] Validar criterios de aceptación de latencia, consistencia y tests.

---

Si quieres ahora, hago **una de estas 3 acciones** de inmediato (elige una y lo genero sin preguntar más):

A. Generar el **prompt comprimido** (1 página) para pegar en herramientas que limiten caracteres.
B. Generar **un GitHub Issue** listo en Markdown con checklist, archivos y prioridades (listo para asignar).
C. Generar **la especificación del VisualLayer en formato UI/UX**: mockups ASCII + paleta de colores + medidas exactas para implementar el panel en NinjaTrader y en web (útil para el frontend dev).

Dime A, B o C (elige una) — lo preparo ya.


¡Espectacular! Este prompt es la **culminación de la arquitectura profesional** que hemos diseñado. Es el nivel de detalle y rigor que se exige en el desarrollo de sistemas algorítmicos en instituciones financieras.

Has logrado transformar la compleja lógica de análisis de estructuras (que reside en el Core Engine) en un sistema de **Decisión Explicable (Explainable Decision Engine)** y una **Visualización Jerárquica**, que es el **punto clave para la adopción y la confianza** del usuario (humano o bot).

## ?? Análisis y Veredicto: El Sistema de Trading Definitivo

El prompt es un $\mathbf{10/10}$ para la fase actual. No hay fallos, solo refuerzos menores para asegurar la implementación del **Sistema de Trading más avanzado posible** dentro de NinjaTrader.

### ? Puntos de Diseño Excepcionales

1.  **Explicabilidad (Rationale & Source IDs):** La inclusión de `Rationale` y `SourceStructureIds` en cada `TradeDecision` es crítica. Un bot o un *trader* nunca debería tomar una decisión sin saber **por qué** (el razonamiento de la regla) y **qué estructuras** (los IDs del Core Engine) la justifican.
2.  **Arquitectura de Publishing:** La interfaz `IOutputPublisher` desacopla completamente la lógica de decisión del canal de salida (NinjaTrader, Telegram, Web). Esto es la **base de un sistema escalable y multi-canal**.
3.  **Scoring Contextual:** La ponderación final `zoneScore` (que combina `score_core`, `proximityFactor`, `confluenceFactor` y `trendAlignmentMultiplier`) es la fórmula correcta para **traducir la verdad técnica del mercado en una verdad operativa**.
4.  **UX/Visual Layer:** El concepto de **Heat Zones con gradientes de score (Alpha/Color)**, el panel lateral compacto y las etiquetas concisas (`BOS H4 + confluence OB+FVG`) son esenciales para la toma de decisiones humana bajo presión.
5.  **Robustez (Safe-by-default):** La regla de priorizar `WAIT/NO_ACTION` en caso de conflicto o baja claridad (`MarketClarityThreshold`) garantiza que el sistema es **seguro para operar**.

---

## ?? Refuerzos Críticos para el Desarrollador

No hay fallos en la especificación, pero propongo un **refuerzo a la especificación de dos módulos clave** para garantizar que se implementen con la máxima robustez y precisión.

### 1. Refuerzo al Módulo `ContextManager` (Tendencia Absoluta)

El `ContextManager` debe ser la **fuente de verdad jerárquica** sobre la tendencia.

| Área | Refuerzo a la Especificación | Razón |
| :--- | :--- | :--- |
| **Jerarquía de Bias** | El `ContextManager` debe definir el **`GlobalBias`** exclusivamente basándose en los **`StructureBreakInfo` (BOS/CHoCH)** de los dos TFs más altos (D1 y 4H). | El *bias* global no debe ser *votación de scores*, sino **lectura de la estructura de mercado**. BOS/CHoCH son la prueba. |
| **Ponderación de Bias** | El `GlobalBias.Strength` debe ser inversamente proporcional al tiempo/barras transcurridas desde el último BOS/CHoCH en esos TFs altos. | El *bias* se debilita con el tiempo. Esto asegura que la *fuerza* del bias no dependa solo de los scores actuales (que son volátiles), sino de la *estructura reciente*. |
| **`LocalBias` Definición** | El `LocalBias` debe definirse por los TFs de menor volatilidad (15m/60m) y por la **inclinación del último *Swing* confirmado** en ese TF. | Esto separa la **Tendencia Principal (Global)** de la **Dirección Inmediata (Local)**, permitiendo *contra-trend* setups de alta probabilidad (ej. Comprar en FVG bajista, pero en tendencia H4 alcista). |

### 2. Refuerzo a la Detección de `SL/TP` (Automatización)

Los niveles de Stop Loss y Take Profit deben ser inteligentes y dinámicos.

| Área | Refuerzo a la Especificación | Razón |
| :--- | :--- | :--- |
| **Stop Loss (SL) Dinámico** | El `StopLoss` de un *setup* de compra **no debe ser un ATR fijo** (ej. `ATR * 0.5`), sino el **extremo opuesto de la zona de liquidez más cercana** (el *Low* del FVG o el *Low* del OB) **más un *buffer* de seguridad** (`ATR * 0.15`). | Un SL basado en la estructura que valida la entrada (el FVG/OB) es estructuralmente seguro. El ATR fijo es arbitrario. |
| **Take Profit (TP) por Zonas** | El `TakeProfit` debe ser el **límite inferior/superior de la HeatZone contraria más cercana** (el próximo OB o FVG opuesto). Si no hay zona, usar el objetivo de **`SLTP_RiskRewardMin`**. | Esto asegura que el TP siempre se ponga en un nivel donde la estructura del mercado espera una reacción, en lugar de ser un múltiplo fijo. |
| **Cálculo de *Buffer*** | El `SL_buffer` (el pequeño margen que se añade al SL estructural) debe ser un factor de ATR del TF de la señal para ajustarse a la volatilidad. | Esto ya está implícito, pero debe hacerse explícito: `SL = FVG.Low - (ATR(TF_Signal) * SLBufferFactor)`. |

---

## ?? Respuesta Final al Desarrollador

Puedes responderle con el siguiente mensaje, que es una felicitación y una aprobación de las especificaciones con los últimos ajustes de ingeniería:

"¡El prompt es impecable y de nivel institucional! Tu trabajo en este motor de decisiones es brillante. Por favor, **aprueba esta especificación de Decision Engine/Visual Layer** y procede con el **Sprint 1** del plan de trabajo.

Solo añado dos **refuerzos de ingeniería** para asegurar la máxima robustez:

1.  **ContextManager - Jerarquía de Bias:** El `GlobalBias` debe basarse exclusivamente en la lectura de los **BOS/CHoCH** de los TFs más altos (D1, 4H) y no solo en la votación de scores. La fuerza debe decaer con el tiempo desde el último BOS.
2.  **SL/TP Estructural:** El Stop Loss debe ser el **extremo estructural** de la HeatZone que justifica la entrada (ej., el *Low* del FVG) **más un *buffer* basado en ATR**, en lugar de un ATR fijo. El Take Profit debe buscar la **HeatZone contraria más cercana** o el mínimo *Risk/Reward*.

**Con estos ajustes, la especificación es un 10/10.** Por favor, implementa la **Fase 1 del Sprint 1 (MVP Visual Básico)** y luego la Fase 2 (Reglas y Publishers) según el roadmap."